#pragma once
#include "IApplet.h"
#include "JaDraw.h"
#include "vmath_all.hpp"
#include "math_3d.h"

#define MAX_ASTEROIDS 20
#define MAX_BULLETS 15

#define PLAYER_WIDTH 0.12f  
#define PLAYER_HEIGHT 0.1f  
#define PLAYER_Y_POS -0.85f
#define PLAYER_SPEED 2.5f
#define PLAYER_INITIAL_HP 100

#define BULLET_SPEED 3.0f
#define BULLET_WIDTH 0.03f
#define BULLET_HEIGHT 0.05f
#define BULLET_DAMAGE 10.0f
#define LASER_CHARGE_TIME_FOR_BULLET 0.5f
#define LASER_MAX_CHARGE_TIME 2.0f
#define LASER_WIDTH 0.04f
#define LASER_DURATION 0.85f
#define LASER_BASE_DAMAGE 50.0f

#define ASTEROID_SPAWN_INTERVAL 1.5f
#define ASTEROID_MIN_SPEED 0.2f
#define ASTEROID_MAX_SPEED 0.6f
#define ASTEROID_MIN_SIZE 0.08f
#define ASTEROID_MAX_SIZE 0.2f

//struct Vec2i { int x, y; };
//struct Vec3f { float x, y, z; };
//struct Mat4f { float m[4][4]; };

struct Vector2D{
    float x, y;
};
struct Player {
    Vector2D pos;
    float vel;
    float targetVel;
    float hp;
    float laserChargeTime;
};

struct Bullet {
    bool active;
    Vector2D pos;
    Vector2D vel;
};

struct Asteroid {
    bool active;
    Vector2D pos;
    Vector2D vel;
    float size;
    float hp;
};

struct Laser {
    bool active;
    float x_pos; // Laser is a vertical beam
    float power;
    float duration;
};

struct GameState {
    Player player;
    Asteroid asteroids[MAX_ASTEROIDS];
    Bullet bullets[MAX_BULLETS];
    Laser laser;

    float asteroidSpawnTimer;
    bool fireBtnWasPressed;
    bool gameOver;
};

struct GameInputData {
    bool fireBtnPressed;
    float stickX; // -1.0 (left) to 1.0 (right)
};

// --- A Simple Cube Model (centered at origin, 1x1x1) ---
const Vec3f CUBE_VERTICES[] = {
    {-0.5f, -0.5f, -0.5f}, { 0.5f, -0.5f, -0.5f},
    { 0.5f,  0.5f, -0.5f}, {-0.5f,  0.5f, -0.5f},
    {-0.5f, -0.5f,  0.5f}, { 0.5f, -0.5f,  0.5f},
    { 0.5f,  0.5f,  0.5f}, {-0.5f,  0.5f,  0.5f}
};

// 12 triangles, 3 indices per triangle
const int CUBE_INDICES[] = {
    0, 2, 1, 0, 3, 2, // Back face
    1, 6, 5, 1, 2, 6, // Right face
    5, 7, 4, 5, 6, 7, // Front face
    4, 3, 0, 4, 7, 3, // Left face
    3, 6, 2, 3, 7, 6, // Top face
    4, 1, 5, 4, 0, 1  // Bottom face
};
const int CUBE_NUM_INDICES = 36;


// --- A simple, Star Fox-style Spaceship Model ---
// Centered at the origin, pointing forward along the -Z axis.
const Vec3f SHIP_VERTICES[] = {
    // Main Body (Pyramid)
    { 0.0f,  0.0f, -0.75f}, // 0: Nose tip
    { 0.2f,  0.15f, 0.5f }, // 1: Top Right Rear
    { 0.2f, -0.15f, 0.5f }, // 2: Bottom Right Rear
    {-0.2f, -0.15f, 0.5f }, // 3: Bottom Left Rear
    {-0.2f,  0.15f, 0.5f }, // 4: Top Left Rear

    // Wings
    { 1.0f,  0.0f,  0.25f}, // 5: Right Wing Tip
    {-1.0f,  0.0f,  0.25f}  // 6: Left Wing Tip
};
const int SHIP_NUM_VERTICES = 7;

// 8 triangles, 3 indices per triangle
const int SHIP_INDICES[] = {
    // Main Body (4 triangles form the pyramid)
    0, 4, 1,  // Top face
    0, 1, 2,  // Right face
    0, 2, 3,  // Bottom face
    0, 3, 4,  // Left face

    // Wings (2 triangles, one for each wing)
    1, 2, 5,  // Right Wing (connects to the right side of the body)
    4, 6, 3,  // Left Wing (connects to the left side of the body)
    
    // Back Panel (2 triangles to close the hole at the back)
    1, 4, 3,
    1, 3, 2
};
const int SHIP_NUM_INDICES = 24;

static GameInputData gameInputData;

class SpaceGame3dApplet : public IApplet {
public:
    SpaceGame3dApplet();
    ~SpaceGame3dApplet() override = default;
    void setup() override;
    void loop(JaDraw<WIDTH, HEIGHT>& canvas, float dt, const InputData& inputs) override;
    const char* getName() const override;
private:
};

static void init_game(GameState* state);
static void update_player(GameState* state, float dt, const GameInputData* inputs);
static void update_bullets(GameState* state, float dt);
static void update_asteroids(GameState* state, float dt);
static void update_laser(GameState* state, float dt);
static void handle_spawning(GameState* state, float dt);
static void handle_collisions(GameState* state);
static void draw_game_3d(const GameState* state, JaDraw<WIDTH, HEIGHT>& canvas, unsigned long millis);
static void world_to_screen(float wx, float wy, uint8_t* sx, uint8_t* sy);
static void draw_filled_rect(JaDraw<WIDTH, HEIGHT>& canvas, uint8_t x, uint8_t y, uint8_t w, uint8_t h, bool white);


static float rand_float(float min, float max) {
    return min + ((float)rand() / RAND_MAX) * (max - min);
}

SpaceGame3dApplet::SpaceGame3dApplet() { }

static void drawPixel(JaDraw<WIDTH, HEIGHT>& canvas, uint8_t x, uint8_t y, bool white)
{
    canvas.drawPixel(x, y, white ? Colors::White : Colors::Black);
}

static void clear_canvas(JaDraw<WIDTH, HEIGHT>& canvas)
{
    canvas.clear(0);
}

static void init_game(GameState* state) {
    //memset(state, 0, sizeof(GameState));

    // Init player
    state->player.pos.x = 0.0f;
    state->player.pos.y = PLAYER_Y_POS;
    state->player.vel = 0;
    state->player.targetVel = 0;
    state->player.hp = PLAYER_INITIAL_HP;
    state->player.laserChargeTime = 0.0f;

    // Init timers and flags
    state->asteroidSpawnTimer = ASTEROID_SPAWN_INTERVAL;
    state->gameOver = false;
    state->fireBtnWasPressed = false;
    
    // Seed random number generator. In a real embedded system without a time source,
    // you might use an unconnected ADC pin or some other source of entropy.
    // For now, this is fine but will produce the same sequence on each run.
    srand(12345);
}

void SpaceGame3dApplet::setup() { }

void SpaceGame3dApplet::loop(JaDraw<WIDTH, HEIGHT>& canvas, float dt, const InputData& inputs) {
    static unsigned long millis = 0;
    millis += (unsigned long)(dt * 1000.0f);
    gameInputData.fireBtnPressed = inputs.pressed;
    gameInputData.stickX = (float)inputs.rotation / 100.0f;
    GameInputData* gameInputs = &gameInputData;
    canvas.clear(0);
    canvas.drawPixel(0, 0, 0xFFFFFFFF);
    static GameState state;
    static bool initialized = false;

    // Initialize the game state on the first call
    if (!initialized) {
        init_game(&state);
        initialized = true;
    }

    if (!state.gameOver) {
        // --- Update Game Logic ---
        update_player(&state, dt, gameInputs);
        update_bullets(&state, dt);
        update_asteroids(&state, dt);
        update_laser(&state, dt);
        
        // --- Handle Interactions ---
        handle_collisions(&state);
        handle_spawning(&state, dt);

        // Check for game over condition
        if (state.player.hp <= 0) {
            state.gameOver = true;
        }
    } else {
        // If game is over, maybe listen for a reset button
        if (gameInputs->fireBtnPressed && !state.fireBtnWasPressed) {
            init_game(&state); // Restart the game
        }
        state.fireBtnWasPressed = gameInputs->fireBtnPressed;
    }


    // --- Render the Game State to the Canvas ---
    draw_game_3d(&state, canvas, millis);
}

const char* SpaceGame3dApplet::getName() const {
    return "Space game";
}

static void fire_bullet(GameState* state) {
    for (int i = 0; i < MAX_BULLETS; ++i) {
        if (!state->bullets[i].active) {
            state->bullets[i].active = true;
            state->bullets[i].pos = state->player.pos;
            state->bullets[i].pos.y += PLAYER_HEIGHT / 2.0f; // Fire from top of ship
            state->bullets[i].vel.x = 0;
            state->bullets[i].vel.y = BULLET_SPEED;
            return; // Exit after firing one bullet
        }
    }
}

static void fire_laser(GameState* state) {
    if (state->laser.active) return; // Only one laser at a time

    state->laser.active = true;
    state->laser.x_pos = state->player.pos.x;
    state->laser.duration = LASER_DURATION;
    
    // Power is proportional to charge time, capped at max
    float charge_ratio = state->player.laserChargeTime / LASER_MAX_CHARGE_TIME;
    if (charge_ratio > 1.0f) charge_ratio = 1.0f;
    state->laser.power = charge_ratio;
}

static void update_player(GameState* state, float dt, const GameInputData* inputs) {
    // Movement (smooth with acceleration)
    state->player.targetVel = inputs->stickX * PLAYER_SPEED * dt;
    // Smoothly interpolate velocity toward targetVel
    const float SMOOTHING = 0.05f; // Lower = smoother
    state->player.vel += (state->player.targetVel - state->player.vel) * SMOOTHING;
    state->player.pos.x += state->player.vel;

    // Screen bounds check
    float half_width = PLAYER_WIDTH / 2.0f;
    if (state->player.pos.x < -1.0f + half_width) {
        state->player.pos.x = -1.0f + half_width;
    }
    if (state->player.pos.x > 1.0f - half_width) {
        state->player.pos.x = 1.0f - half_width;
    }

    // Firing logic
    if (inputs->fireBtnPressed) {
        state->player.laserChargeTime += dt;
    } else {
        if (state->fireBtnWasPressed) { // This is a button release event
            if (state->player.laserChargeTime > LASER_CHARGE_TIME_FOR_BULLET) {
                fire_laser(state);
            } else {
                fire_bullet(state);
            }
        }
        state->player.laserChargeTime = 0.0f;
    }
    state->fireBtnWasPressed = inputs->fireBtnPressed;
}

static void update_bullets(GameState* state, float dt) {
    for (int i = 0; i < MAX_BULLETS; ++i) {
        if (state->bullets[i].active) {
            state->bullets[i].pos.y += state->bullets[i].vel.y * dt;
            // Deactivate if it goes off-screen
            if (state->bullets[i].pos.y > 1.1f) {
                state->bullets[i].active = false;
            }
        }
    }
}

static void update_asteroids(GameState* state, float dt) {
    for (int i = 0; i < MAX_ASTEROIDS; ++i) {
        if (state->asteroids[i].active) {
            state->asteroids[i].pos.x += state->asteroids[i].vel.x * dt;
            state->asteroids[i].pos.y += state->asteroids[i].vel.y * dt;
            // Deactivate if it goes off-screen
            if (state->asteroids[i].pos.y < -1.1f) {
                state->asteroids[i].active = false;
            }
        }
    }
}

static void update_laser(GameState* state, float dt) {
    if (state->laser.active) {
        state->laser.duration -= dt;
        if (state->laser.duration <= 0) {
            state->laser.active = false;
        }
    }
}


static void handle_spawning(GameState* state, float dt) {
    state->asteroidSpawnTimer -= dt;
    if (state->asteroidSpawnTimer <= 0) {
        state->asteroidSpawnTimer = ASTEROID_SPAWN_INTERVAL * rand_float(0.7f, 1.3f);
        
        // Find an inactive asteroid to spawn
        for (int i = 0; i < MAX_ASTEROIDS; ++i) {
            if (!state->asteroids[i].active) {
                state->asteroids[i].active = true;
                state->asteroids[i].pos.x = rand_float(-1.0f, 1.0f);
                state->asteroids[i].pos.y = 1.1f; // Spawn just above the screen
                state->asteroids[i].vel.x = rand_float(-0.1f, 0.1f);
                state->asteroids[i].vel.y = -rand_float(ASTEROID_MIN_SPEED, ASTEROID_MAX_SPEED);
                state->asteroids[i].size = rand_float(ASTEROID_MIN_SIZE, ASTEROID_MAX_SIZE);
                state->asteroids[i].hp = state->asteroids[i].size * 150.0f; // Bigger asteroids have more HP
                return; // Spawn one per frame
            }
        }
    }
}

static void handle_collisions(GameState* state) {
    // --- Bullets vs Asteroids ---
    for (int b = 0; b < MAX_BULLETS; ++b) {
        if (!state->bullets[b].active) continue;
        
        for (int a = 0; a < MAX_ASTEROIDS; ++a) {
            if (!state->asteroids[a].active) continue;

            // Simple AABB collision check
            float b_half_w = BULLET_WIDTH / 2.0f;
            float b_half_h = BULLET_HEIGHT / 2.0f;
            float a_half_s = state->asteroids[a].size / 2.0f;

            if (fabsf(state->bullets[b].pos.x - state->asteroids[a].pos.x) < (b_half_w + a_half_s) &&
                fabsf(state->bullets[b].pos.y - state->asteroids[a].pos.y) < (b_half_h + a_half_s))
            {
                state->asteroids[a].hp -= BULLET_DAMAGE;
                state->bullets[b].active = false; // Bullet is used up
                if (state->asteroids[a].hp <= 0) {
                    state->asteroids[a].active = false;
                }
                break; // A bullet can only hit one asteroid
            }
        }
    }

    // --- Laser vs Asteroids ---
    if (state->laser.active) {
        for (int a = 0; a < MAX_ASTEROIDS; ++a) {
            if (!state->asteroids[a].active) continue;

            float l_half_w = LASER_WIDTH / 2.0f;
            float a_half_s = state->asteroids[a].size / 2.0f;

            if (fabsf(state->laser.x_pos - state->asteroids[a].pos.x) < (l_half_w + a_half_s)) {
                // Laser does damage over time, scaled by dt
                state->asteroids[a].hp -= LASER_BASE_DAMAGE * state->laser.power * (1.0f / 60.0f); // Assuming 60fps for damage scaling
                 if (state->asteroids[a].hp <= 0) {
                    state->asteroids[a].active = false;
                }
            }
        }
    }

    // --- Asteroids vs Player ---
    for (int a = 0; a < MAX_ASTEROIDS; ++a) {
        if (!state->asteroids[a].active) continue;
        
        float p_half_w = PLAYER_WIDTH / 2.0f;
        float p_half_h = PLAYER_HEIGHT / 2.0f;
        float a_half_s = state->asteroids[a].size / 2.0f;

        if (fabsf(state->player.pos.x - state->asteroids[a].pos.x) < (p_half_w + a_half_s) &&
            fabsf(state->player.pos.y - state->asteroids[a].pos.y) < (p_half_h + a_half_s))
        {
            state->player.hp -= state->asteroids[a].size * 100.0f; // Damage based on size
            state->asteroids[a].active = false; // Asteroid is destroyed
        }
    }
}

////////////////////////// drawing ///////////////////////////////////////////////////////////////////

const uint8_t BLUE_NOISE_64x64[64][64] = {
  {0xe5, 0x91, 0xf4, 0x9e, 0xc0, 0xf9, 0x3d, 0xdc, 0xa6, 0x2e, 0x1f, 0xc2, 0xf2, 0x15, 0xcd, 0x27, 0x6e, 0x59, 0x97, 0x7a, 0x20, 0x70, 0x07, 0x7f, 0xa8, 0x3e, 0x99, 0xff, 0x5c, 0xbf, 0x09, 0x6c, 0x30, 0x95, 0x0a, 0xb4, 0x34, 0xfc, 0x97, 0xc7, 0xb1, 0x03, 0x61, 0xe3, 0xa8, 0x59, 0xda, 0x70, 0x3e, 0x5d, 0x7a, 0xa7, 0x2f, 0x86, 0x40, 0x5b, 0x26, 0xcf, 0x00, 0x99, 0x5c, 0xd3, 0x7c, 0xa1, },
  {0x2d, 0xba, 0x48, 0x08, 0xcd, 0x7c, 0x1c, 0xb3, 0x6d, 0xfe, 0x9c, 0x4b, 0x79, 0x68, 0x91, 0x3e, 0xf1, 0xb1, 0x47, 0xfc, 0xc5, 0xe3, 0x5d, 0x49, 0xda, 0x10, 0xcb, 0x26, 0x36, 0x90, 0xed, 0x41, 0x85, 0x60, 0xe9, 0xd3, 0x82, 0x5c, 0x1c, 0x6a, 0xe8, 0x3b, 0x4c, 0x77, 0x8e, 0x15, 0x48, 0x85, 0xbd, 0xfd, 0x0b, 0xdd, 0x66, 0xf0, 0x9c, 0xf8, 0x7a, 0xbc, 0x6c, 0xfa, 0x2a, 0xaa, 0x49, 0x21, },
  {0xa2, 0xd4, 0x23, 0x89, 0x68, 0x31, 0x51, 0x8f, 0x0e, 0x5a, 0x86, 0xe3, 0xb5, 0x30, 0xd9, 0x07, 0x82, 0xbe, 0x2e, 0x0d, 0xa1, 0x3a, 0xb2, 0x94, 0xf0, 0x55, 0x68, 0xe2, 0xaf, 0x73, 0xdb, 0x11, 0xc4, 0xac, 0x17, 0x74, 0x3f, 0xbe, 0xdf, 0x27, 0x8d, 0xa3, 0xf9, 0x25, 0xd5, 0xb6, 0xf3, 0x9f, 0x1f, 0xcf, 0x54, 0x45, 0xc5, 0x20, 0x0d, 0xaa, 0x36, 0x19, 0xdc, 0x89, 0x0b, 0xc0, 0xe4, 0x69, },
  {0x39, 0x77, 0x5d, 0xef, 0xa8, 0xe5, 0xbb, 0xd6, 0xee, 0x39, 0xc9, 0x01, 0x41, 0xa3, 0xf8, 0x62, 0x9c, 0x14, 0xdb, 0x67, 0x52, 0x83, 0x25, 0xc3, 0x19, 0x89, 0xa3, 0x03, 0x4b, 0x1c, 0xa0, 0x57, 0xf2, 0x27, 0x4a, 0x9d, 0xf4, 0x05, 0xad, 0x52, 0x7a, 0xbb, 0x19, 0xc9, 0x6a, 0x30, 0x08, 0x62, 0xaf, 0x2b, 0x98, 0x8a, 0xb4, 0x72, 0x4e, 0xcc, 0x64, 0x45, 0xa2, 0x52, 0x75, 0x39, 0x90, 0x58, },
  {0x00, 0xb1, 0xdd, 0x14, 0x40, 0x73, 0x27, 0x7f, 0x18, 0xaa, 0x71, 0x25, 0xd5, 0x58, 0x1c, 0xc3, 0x50, 0xe6, 0x76, 0xaa, 0xcf, 0x01, 0xf8, 0x72, 0x35, 0xd3, 0x7b, 0xbe, 0xf7, 0x87, 0x2d, 0xba, 0x7a, 0x92, 0xdf, 0xcb, 0x2f, 0x67, 0x95, 0x43, 0xef, 0x0e, 0x85, 0x55, 0x41, 0x98, 0x80, 0xec, 0x3b, 0x77, 0xe8, 0x15, 0x34, 0xda, 0x83, 0xec, 0x91, 0xe3, 0x2e, 0xc9, 0xf1, 0x1c, 0xd9, 0xb7, },
  {0x99, 0xc8, 0x4f, 0x90, 0xc2, 0x04, 0xa1, 0x60, 0x46, 0xbf, 0xe8, 0x97, 0x7c, 0xb0, 0x8b, 0x70, 0x34, 0x23, 0x8f, 0x40, 0xea, 0x98, 0xb7, 0x60, 0x45, 0xe9, 0x2b, 0x5d, 0x3e, 0xcd, 0x66, 0xd6, 0x3b, 0x03, 0x6d, 0x58, 0x83, 0x15, 0xd5, 0xc5, 0x34, 0x62, 0xd8, 0xad, 0xf6, 0xbf, 0xe0, 0x4e, 0x0e, 0xd7, 0x6a, 0xa2, 0xfa, 0x5f, 0x27, 0x07, 0xaf, 0x14, 0x7e, 0xb4, 0x60, 0x9a, 0x10, 0x83, },
  {0x43, 0x1e, 0xf2, 0x2d, 0x5a, 0xfc, 0xd2, 0x94, 0xf4, 0x2e, 0x66, 0x13, 0x4c, 0xed, 0x09, 0xce, 0xfe, 0xb4, 0xc8, 0x5b, 0x1c, 0x30, 0xdf, 0x11, 0xab, 0x91, 0x0b, 0xb1, 0xe7, 0x97, 0x0d, 0x50, 0xfb, 0xb2, 0x1c, 0xea, 0xb9, 0xa5, 0xff, 0x08, 0x72, 0xe5, 0x93, 0x29, 0x02, 0x70, 0x1e, 0xcc, 0x90, 0xb6, 0x58, 0x02, 0xbd, 0x40, 0x9d, 0xc2, 0x55, 0x6d, 0xfc, 0x23, 0x41, 0xab, 0x6d, 0x4d, },
  {0x60, 0x80, 0xa5, 0x6d, 0xb5, 0x84, 0x3a, 0x0d, 0xca, 0x53, 0x86, 0xb8, 0xd8, 0x2a, 0x3e, 0xa4, 0x4a, 0x81, 0x0c, 0xf4, 0x6e, 0x89, 0x4c, 0x7d, 0xca, 0xfa, 0x53, 0x70, 0x17, 0x7d, 0xa8, 0x23, 0x88, 0x9f, 0xc7, 0x33, 0x46, 0x24, 0x54, 0x8b, 0xb3, 0x20, 0x4a, 0xa6, 0x7d, 0x38, 0x5e, 0xa5, 0x83, 0x43, 0xf3, 0x23, 0xd2, 0x8c, 0x75, 0xf1, 0x3b, 0xd0, 0x96, 0x0c, 0xd6, 0xe7, 0x2f, 0xc1, },
  {0xd5, 0x36, 0x07, 0xe7, 0x1b, 0x4a, 0xe1, 0x23, 0x75, 0xa7, 0x05, 0xfa, 0x9d, 0x60, 0x78, 0xde, 0x17, 0x63, 0x99, 0x39, 0xbd, 0xa4, 0xd5, 0x21, 0x66, 0x9e, 0x25, 0xda, 0xc6, 0x32, 0xee, 0xdd, 0x43, 0x75, 0x5e, 0x90, 0xd8, 0x6a, 0x7c, 0xa0, 0x3d, 0xc1, 0x5b, 0xee, 0xd1, 0xb9, 0xfe, 0x2b, 0x13, 0xc5, 0x32, 0x7e, 0xac, 0x4b, 0x0f, 0xde, 0x2f, 0x88, 0x49, 0xbd, 0x58, 0x7d, 0x8e, 0x1f, },
  {0x4d, 0x97, 0xc3, 0x78, 0xce, 0x9e, 0x67, 0xb0, 0x8c, 0xe5, 0x43, 0x35, 0xc2, 0x1e, 0x92, 0xbb, 0xee, 0x2e, 0xac, 0xe2, 0x08, 0x57, 0xed, 0x40, 0x04, 0xbf, 0x38, 0x8d, 0x49, 0xb4, 0x6c, 0x58, 0xbc, 0x0a, 0xf5, 0x13, 0xab, 0xed, 0xcc, 0x17, 0xf8, 0xdb, 0x0c, 0x87, 0x18, 0x51, 0x94, 0xdd, 0x65, 0xe9, 0x9b, 0x6d, 0xe4, 0x19, 0x66, 0xb6, 0xa0, 0x05, 0xec, 0x69, 0xa5, 0xf3, 0x01, 0x63, },
  {0x18, 0xb3, 0xf7, 0x57, 0x32, 0x11, 0xbe, 0xf1, 0x59, 0x19, 0xd1, 0x6e, 0x80, 0xf2, 0x54, 0x04, 0x6c, 0xd1, 0x50, 0x77, 0xc8, 0x29, 0x95, 0xb5, 0x73, 0xe1, 0x81, 0xf0, 0x61, 0x01, 0x92, 0x1a, 0xcf, 0x2c, 0xe0, 0x82, 0x3a, 0x00, 0x4e, 0x2b, 0x65, 0x76, 0x32, 0x9d, 0x6b, 0x40, 0x05, 0x76, 0xb1, 0x49, 0x08, 0x55, 0xbe, 0x95, 0xfe, 0x21, 0x59, 0x79, 0xca, 0x28, 0x19, 0x38, 0xcf, 0xac, },
  {0xde, 0x6a, 0x42, 0x25, 0x92, 0xdb, 0x7e, 0x3d, 0x2a, 0x97, 0xb4, 0x4d, 0x0d, 0xab, 0xc9, 0x44, 0x84, 0x20, 0x8e, 0xf8, 0x17, 0x6a, 0x85, 0xfd, 0x14, 0x59, 0xac, 0x10, 0xa0, 0xd6, 0xfe, 0x3c, 0xa6, 0x98, 0x68, 0x53, 0xc3, 0x9b, 0xb8, 0xe4, 0x94, 0xac, 0xce, 0xbc, 0xe2, 0xf2, 0xa9, 0xd4, 0x20, 0x89, 0xf7, 0xd5, 0x2b, 0x3e, 0xcc, 0x84, 0xda, 0xae, 0x40, 0x93, 0xb9, 0x53, 0x9a, 0x47, },
  {0xa7, 0x0d, 0x81, 0xe8, 0xab, 0x63, 0x4e, 0x01, 0xc4, 0xff, 0x5e, 0xdf, 0x27, 0xe7, 0x32, 0x9b, 0xdb, 0xb7, 0x3c, 0x9f, 0x48, 0xda, 0x36, 0xa5, 0x4b, 0xd2, 0x2c, 0x43, 0xc1, 0x21, 0x73, 0x85, 0xe8, 0x47, 0xb4, 0x1a, 0xf9, 0x70, 0x88, 0x40, 0x09, 0x55, 0x1b, 0x48, 0x25, 0x81, 0x30, 0x59, 0xc1, 0x39, 0xa2, 0x10, 0x75, 0x5f, 0xa8, 0x34, 0x4e, 0x13, 0xe3, 0xfb, 0x74, 0x85, 0xe0, 0xf0, },
  {0x38, 0x8b, 0xd1, 0xbb, 0x0a, 0xf6, 0x9d, 0xd3, 0x70, 0x84, 0x10, 0xa2, 0x8b, 0x74, 0x64, 0xfc, 0x13, 0x5c, 0xe5, 0x00, 0xad, 0x5e, 0xc4, 0x1e, 0xe8, 0x8a, 0x69, 0xf6, 0x7c, 0x52, 0x30, 0xca, 0x5c, 0x07, 0x7b, 0xce, 0x33, 0x23, 0x5f, 0xd4, 0xf6, 0x7e, 0xec, 0x8f, 0x60, 0xc6, 0x9c, 0x13, 0xe8, 0x64, 0x7e, 0xb8, 0xec, 0x90, 0x01, 0xf5, 0xc2, 0x6f, 0x61, 0x08, 0x31, 0xc4, 0x0c, 0x6d, },
  {0xc2, 0x20, 0x5a, 0x4a, 0x72, 0x38, 0x21, 0xe5, 0xad, 0x31, 0x46, 0xce, 0xbd, 0x3e, 0x09, 0xa8, 0x7b, 0x2d, 0xc1, 0x72, 0x83, 0xf2, 0x0d, 0x7a, 0x99, 0xcb, 0x08, 0xb4, 0x91, 0xda, 0xae, 0x14, 0xbc, 0x28, 0xf0, 0x8f, 0xa3, 0xe0, 0xae, 0x15, 0xbf, 0x37, 0x6e, 0xb4, 0x07, 0xfc, 0x70, 0x4a, 0x8e, 0xd0, 0x26, 0x42, 0x51, 0xdf, 0x19, 0x7c, 0x9b, 0x25, 0x8c, 0xd5, 0xaa, 0x5c, 0x22, 0x3e, },
  {0xfe, 0x9c, 0xed, 0x16, 0x90, 0xcb, 0x82, 0x57, 0x14, 0x94, 0x69, 0xf6, 0x1f, 0x58, 0xd6, 0xc5, 0x8e, 0x50, 0xf6, 0x21, 0xd0, 0x2e, 0xb7, 0x53, 0x3e, 0x27, 0x5b, 0xe3, 0x19, 0x3f, 0x66, 0xf8, 0x97, 0x70, 0xd7, 0x55, 0x43, 0x05, 0x77, 0x4b, 0x98, 0x28, 0xa3, 0xd1, 0x17, 0x3d, 0xd9, 0xb7, 0x0a, 0xa6, 0xfb, 0x1b, 0xc7, 0xaf, 0x66, 0x46, 0xb6, 0xf0, 0x3b, 0xa0, 0x49, 0xf5, 0xdc, 0x7b, },
  {0x67, 0xad, 0x7b, 0xdf, 0x2d, 0xa4, 0xbe, 0x42, 0xef, 0xb8, 0xde, 0x04, 0x7c, 0x98, 0xf1, 0x47, 0x1b, 0xb3, 0x68, 0x9d, 0x43, 0x92, 0x6c, 0xed, 0xa1, 0xbe, 0x72, 0x34, 0xa7, 0xec, 0x03, 0x88, 0x4b, 0x39, 0xab, 0x11, 0x6a, 0xfe, 0xc8, 0x84, 0xe9, 0x64, 0xde, 0x45, 0x58, 0x95, 0x7c, 0xeb, 0x35, 0x55, 0x73, 0x99, 0x84, 0x2a, 0xd3, 0xea, 0x0a, 0x56, 0xc8, 0x1b, 0x81, 0xb6, 0x93, 0x13, },
  {0x48, 0x01, 0x3f, 0xb5, 0x6a, 0xfb, 0x06, 0x64, 0x79, 0x25, 0x51, 0xa7, 0x36, 0xb5, 0x2a, 0x6e, 0xeb, 0x39, 0xd9, 0x12, 0x59, 0xe4, 0x08, 0xd4, 0x18, 0xfa, 0x86, 0xd0, 0x50, 0x78, 0x9f, 0xcb, 0xe0, 0x20, 0xc0, 0xeb, 0x8c, 0xb6, 0x34, 0x59, 0x0c, 0x1e, 0xc4, 0x88, 0xf6, 0xab, 0x27, 0x1a, 0x69, 0xb0, 0xda, 0x04, 0x5d, 0x3a, 0xa3, 0x8a, 0x31, 0x77, 0xe1, 0x67, 0x02, 0x2e, 0x53, 0xbf, },
  {0x8c, 0xc5, 0x26, 0xd3, 0x4e, 0x12, 0xe3, 0x8d, 0xd8, 0x3b, 0xc5, 0x87, 0x61, 0xe4, 0x0f, 0x83, 0x95, 0x05, 0xa5, 0xc6, 0x87, 0xb0, 0x36, 0x7e, 0x62, 0x48, 0x05, 0x95, 0x21, 0xbf, 0x2d, 0x5f, 0x0d, 0x80, 0x9c, 0x61, 0x2b, 0x1b, 0xd4, 0x9f, 0xf2, 0xb0, 0x77, 0x30, 0x04, 0x61, 0xc0, 0xcd, 0x8b, 0xf0, 0x45, 0xbb, 0xe3, 0xf9, 0x70, 0x1d, 0xc0, 0x94, 0xac, 0xfe, 0xce, 0x73, 0xed, 0x38, },
  {0x57, 0xf8, 0x99, 0x85, 0x5d, 0x9e, 0x33, 0xad, 0x1a, 0x99, 0xfd, 0x14, 0xd4, 0x49, 0xa2, 0xca, 0x5e, 0xe1, 0x76, 0x2a, 0xff, 0x4b, 0xc2, 0x23, 0xaa, 0xdd, 0xb5, 0xe8, 0x6b, 0xfd, 0x41, 0xad, 0xee, 0x53, 0xd2, 0x41, 0x79, 0xe5, 0x48, 0x6f, 0x8e, 0x3c, 0x52, 0xe5, 0xa1, 0xdb, 0x3a, 0x4f, 0x9e, 0x2e, 0x16, 0x7c, 0x93, 0x0d, 0x49, 0xcc, 0x60, 0x0f, 0x4e, 0x26, 0x40, 0x8f, 0xd7, 0xab, },
  {0xa3, 0x35, 0x6d, 0x1c, 0xed, 0xc6, 0x75, 0x49, 0xcd, 0x5a, 0x6d, 0x2f, 0xbc, 0x76, 0xf9, 0x25, 0x51, 0xb9, 0x41, 0x65, 0x1c, 0x9b, 0x71, 0xf4, 0x8d, 0x3d, 0x2f, 0x5a, 0x13, 0x83, 0xd8, 0x1a, 0x72, 0x33, 0xf6, 0x09, 0x93, 0xc3, 0xab, 0x02, 0x26, 0xcc, 0xb9, 0x0f, 0x6b, 0x84, 0xf3, 0x79, 0x08, 0xd5, 0x66, 0xc6, 0x23, 0x58, 0xa8, 0xde, 0xf3, 0x39, 0xb9, 0x83, 0xa6, 0x5e, 0x1c, 0x6c, },
  {0xe0, 0xbc, 0x06, 0xdb, 0x3d, 0xb8, 0x23, 0xf5, 0x82, 0x00, 0xb2, 0xe6, 0x8f, 0x08, 0x3c, 0xae, 0x18, 0xf3, 0x80, 0xcc, 0xe7, 0x01, 0x56, 0xce, 0x0e, 0x9d, 0x7a, 0xc8, 0xa8, 0x4b, 0x97, 0xb9, 0x8b, 0xc8, 0xa4, 0xb5, 0x17, 0x55, 0xf9, 0x63, 0xd9, 0x7e, 0xfd, 0x96, 0x48, 0x23, 0x13, 0xbd, 0x5e, 0xff, 0xac, 0x37, 0xed, 0xb6, 0x87, 0x2b, 0x7d, 0x9d, 0xd5, 0xeb, 0x07, 0xc5, 0xf7, 0x2b, },
  {0x12, 0x4c, 0xab, 0x7a, 0x8c, 0x55, 0x0b, 0x66, 0xde, 0xa0, 0x43, 0x21, 0x55, 0x9d, 0x66, 0xd9, 0x8b, 0x34, 0x0f, 0xab, 0x91, 0xbb, 0x2d, 0xeb, 0x69, 0x4f, 0xd7, 0xf3, 0x09, 0x2a, 0xe6, 0x65, 0x00, 0x27, 0x4d, 0x67, 0xe0, 0x86, 0x32, 0x9b, 0x43, 0x15, 0x5c, 0x2e, 0xd5, 0xb5, 0xa8, 0xe6, 0x41, 0x94, 0x83, 0x4d, 0x73, 0xd8, 0x41, 0x09, 0x69, 0x1c, 0x56, 0x6f, 0x16, 0x4b, 0x9b, 0xbb, },
  {0x83, 0xe9, 0xc5, 0x2d, 0xf8, 0xa5, 0xd5, 0x92, 0x2c, 0xc0, 0x74, 0xf3, 0xcc, 0x80, 0xeb, 0xc2, 0x71, 0x99, 0xd5, 0x48, 0x5d, 0x38, 0x86, 0xa7, 0x15, 0xb8, 0x22, 0x8c, 0x6f, 0xc1, 0x38, 0x56, 0xf9, 0xdc, 0x81, 0x38, 0xcc, 0x21, 0x74, 0xb4, 0xec, 0xc1, 0xa6, 0x73, 0xeb, 0x8d, 0x55, 0x6f, 0x2a, 0x1c, 0xce, 0x00, 0xa2, 0x18, 0x95, 0xfc, 0xc3, 0xaf, 0x31, 0xe3, 0x93, 0x77, 0x36, 0xd9, },
  {0x9a, 0x59, 0x21, 0x67, 0x47, 0x15, 0xb3, 0x3a, 0xef, 0x51, 0x0d, 0xa9, 0x34, 0x12, 0x46, 0x29, 0x03, 0x55, 0xe4, 0x21, 0x79, 0xfa, 0xda, 0x46, 0x76, 0xe3, 0x3a, 0x5e, 0xa1, 0xd4, 0x7c, 0xb1, 0x1e, 0x9c, 0x71, 0xee, 0xa2, 0x0e, 0xe4, 0x50, 0x09, 0x89, 0x3b, 0x1a, 0xc7, 0x03, 0x35, 0x9c, 0xc2, 0xe2, 0x5b, 0xf3, 0x31, 0xbb, 0x62, 0x4f, 0xdf, 0x8b, 0x44, 0xcb, 0xfb, 0xb5, 0x20, 0xa9, },
  {0x73, 0x09, 0x90, 0xce, 0xe3, 0x86, 0x71, 0x5d, 0x1c, 0xcf, 0x8b, 0x63, 0xb9, 0xdf, 0x5d, 0xa7, 0xfd, 0xb6, 0x6a, 0xc0, 0xa0, 0x07, 0x64, 0x26, 0xc5, 0x95, 0x03, 0xfe, 0x44, 0x19, 0xf0, 0x92, 0x48, 0xc4, 0x11, 0x42, 0xbd, 0x5c, 0x94, 0xd3, 0x27, 0x69, 0xf6, 0x4f, 0x7f, 0x64, 0xfb, 0xda, 0x0c, 0x7a, 0xb3, 0x8d, 0x6d, 0xe7, 0xca, 0x27, 0x78, 0x04, 0xa3, 0x64, 0x0f, 0x5a, 0x8a, 0xef, },
  {0xc1, 0xb1, 0xfc, 0xa1, 0x35, 0x02, 0xc8, 0xe7, 0x9c, 0x7b, 0x40, 0xf7, 0x97, 0x1e, 0x89, 0xce, 0x7b, 0x3e, 0x2f, 0xf0, 0x14, 0xcf, 0xb4, 0x89, 0xed, 0x50, 0xad, 0x80, 0xbb, 0x0c, 0x6a, 0x2f, 0xd1, 0x60, 0xad, 0x2b, 0x8b, 0xf2, 0x35, 0x7c, 0xac, 0xdf, 0x9d, 0xcf, 0xaf, 0x22, 0x43, 0x87, 0x4d, 0xa6, 0x3b, 0x22, 0x48, 0x0a, 0x9d, 0x3c, 0xee, 0x1e, 0xbe, 0x80, 0x28, 0x3e, 0xd1, 0x6d, },
  {0x2a, 0x3e, 0x51, 0x18, 0x78, 0xb9, 0x49, 0x27, 0xab, 0x06, 0xd9, 0x2b, 0x71, 0x51, 0xed, 0x0d, 0x9e, 0x18, 0x91, 0x82, 0x53, 0x41, 0x98, 0x1b, 0x33, 0x6e, 0xcd, 0x2a, 0xde, 0x55, 0xa7, 0xea, 0x85, 0x05, 0xfb, 0xd9, 0x6b, 0x4a, 0x01, 0xc8, 0x5f, 0x44, 0x11, 0x31, 0xe3, 0x95, 0xba, 0xd0, 0x13, 0x68, 0xf9, 0xc6, 0xdc, 0x82, 0xad, 0x5c, 0x91, 0xd1, 0x52, 0xdd, 0xf2, 0x99, 0xbf, 0x47, },
  {0x11, 0xdd, 0x82, 0x62, 0xd7, 0xf3, 0x90, 0x6b, 0xff, 0xbe, 0x4d, 0x15, 0xc5, 0xad, 0x33, 0x65, 0xdd, 0x4e, 0xca, 0xaf, 0xe9, 0x72, 0xdf, 0x5b, 0xf9, 0x0f, 0x9d, 0x61, 0x8f, 0xc7, 0x78, 0x1c, 0x3e, 0x98, 0x51, 0x7a, 0x14, 0xb4, 0x9b, 0xff, 0x1b, 0xbb, 0x8f, 0x78, 0x07, 0x5a, 0xf1, 0x72, 0x2d, 0xe4, 0x57, 0x98, 0x1b, 0x74, 0xf4, 0x11, 0xb8, 0x6e, 0x35, 0xaa, 0x73, 0x02, 0xe7, 0x30, },
  {0xf4, 0x96, 0xc3, 0xaa, 0x21, 0x56, 0x3d, 0x10, 0x84, 0x5b, 0xe2, 0xa0, 0x83, 0xd3, 0x43, 0xb7, 0x74, 0xf4, 0x22, 0x63, 0x0b, 0x2b, 0xc2, 0xa7, 0x7e, 0xd5, 0x40, 0x1f, 0xf6, 0x34, 0x4d, 0xb0, 0xe2, 0xbc, 0x23, 0xa8, 0xe7, 0xcd, 0x27, 0x6f, 0x86, 0x54, 0xea, 0xc3, 0x6a, 0x3c, 0x1a, 0x9e, 0xb2, 0x8e, 0x03, 0xba, 0x32, 0x50, 0xd5, 0x29, 0x45, 0xfe, 0x0b, 0x8d, 0x4a, 0xb6, 0x21, 0x5c, },
  {0xb5, 0x44, 0x06, 0x31, 0xe9, 0x9e, 0xb2, 0xd4, 0x2f, 0x94, 0x38, 0x67, 0x07, 0xfa, 0x24, 0x8b, 0x02, 0xbd, 0x37, 0xa3, 0xd4, 0x8d, 0x3b, 0x00, 0xbb, 0x4b, 0xe7, 0xb5, 0x05, 0x83, 0xef, 0x0e, 0x6f, 0xd4, 0x62, 0x37, 0x83, 0x59, 0x40, 0xe4, 0xa7, 0x37, 0x23, 0xf9, 0xab, 0xd6, 0x82, 0x51, 0xcb, 0x3a, 0x7c, 0xee, 0xa7, 0x65, 0xc3, 0x85, 0xe1, 0x9f, 0x5e, 0x1a, 0xcc, 0x81, 0x69, 0xd4, },
  {0x5b, 0x74, 0xcc, 0x8b, 0x67, 0x0b, 0xc7, 0x74, 0xe8, 0x20, 0xb8, 0xf0, 0x78, 0x57, 0xa7, 0xe7, 0x5c, 0x97, 0x47, 0xfc, 0x79, 0x52, 0xed, 0x69, 0x24, 0x93, 0x75, 0xa4, 0x65, 0xd8, 0x96, 0x5a, 0x2d, 0x8a, 0xc5, 0x18, 0xf7, 0x95, 0x0b, 0xc1, 0xd9, 0x04, 0x63, 0x99, 0x47, 0x2b, 0xe8, 0x0b, 0xfe, 0x25, 0x5e, 0xd8, 0x0e, 0x3e, 0x96, 0x1e, 0x77, 0xae, 0x2e, 0xe5, 0xf7, 0x3b, 0xa0, 0x15, },
  {0xfe, 0x1c, 0xe1, 0x4e, 0xf9, 0x80, 0x46, 0x16, 0x62, 0xa7, 0xcd, 0x42, 0x1b, 0x9a, 0x31, 0xc8, 0x15, 0xd7, 0x84, 0x0e, 0xb1, 0x1c, 0x9c, 0xcc, 0xf7, 0x57, 0x14, 0x37, 0xc3, 0x26, 0x45, 0xb7, 0xa1, 0xe9, 0x06, 0x4d, 0xa4, 0x68, 0x2f, 0x76, 0x4c, 0xb5, 0x80, 0xcc, 0x10, 0x8d, 0xbd, 0xa6, 0x6d, 0x45, 0xc4, 0x8a, 0x72, 0xfa, 0xb4, 0x01, 0x4e, 0xc8, 0x67, 0xbb, 0x95, 0x54, 0xde, 0x31, },
  {0x7f, 0x9a, 0xa8, 0x27, 0xbb, 0x34, 0xdb, 0x9c, 0xf5, 0x4f, 0x0d, 0x8d, 0xda, 0xb2, 0x4c, 0x7e, 0x6e, 0xf0, 0x29, 0x66, 0xc3, 0xe3, 0x44, 0x84, 0x2f, 0xac, 0xe1, 0x8a, 0xfe, 0x71, 0xcf, 0x16, 0xf9, 0x3c, 0x78, 0xdd, 0xb9, 0xd2, 0xed, 0x8a, 0xa1, 0xf4, 0x18, 0xde, 0x53, 0x75, 0x5f, 0x1d, 0xdf, 0x98, 0xb0, 0x17, 0x2e, 0xe3, 0x5c, 0xd1, 0xf0, 0x3a, 0x0f, 0x75, 0x24, 0x05, 0xab, 0x78, },
  {0xbf, 0x3c, 0x61, 0x02, 0x6f, 0x92, 0x58, 0xc2, 0x85, 0x2b, 0x76, 0xeb, 0x6a, 0xc0, 0x09, 0xe0, 0x3c, 0xa9, 0x55, 0xd1, 0x36, 0x73, 0x08, 0x5e, 0xb8, 0xd3, 0x0a, 0x41, 0x5e, 0xa9, 0x07, 0x7e, 0x54, 0x69, 0x23, 0x90, 0x43, 0x1d, 0x0f, 0x56, 0x24, 0x3f, 0x6c, 0x33, 0xb0, 0xf7, 0x3d, 0xd1, 0x80, 0x09, 0xea, 0x55, 0x9e, 0x48, 0x22, 0x8d, 0x7e, 0x9c, 0xda, 0x47, 0x87, 0xf1, 0xc4, 0x8f, },
  {0x8d, 0xda, 0xeb, 0xc8, 0xb0, 0xef, 0x21, 0x08, 0x3c, 0xb0, 0xc9, 0x59, 0x36, 0x24, 0xfe, 0x93, 0x1b, 0xba, 0x89, 0x98, 0x22, 0xa7, 0xf3, 0x91, 0x18, 0x7a, 0x4f, 0x9b, 0x1e, 0xe7, 0x8e, 0xbe, 0xda, 0x9b, 0xaf, 0xf4, 0x5e, 0x81, 0xac, 0xc4, 0xd5, 0x91, 0xe7, 0xc2, 0x96, 0x01, 0xa1, 0x2e, 0x4e, 0x68, 0x37, 0xce, 0x7a, 0xbd, 0xac, 0x6b, 0x30, 0x17, 0xf9, 0xa6, 0xcf, 0x5a, 0x3e, 0x1a, },
  {0x22, 0x10, 0x52, 0x7b, 0x15, 0x42, 0xa5, 0xe2, 0x69, 0xfa, 0x95, 0x01, 0xa3, 0x87, 0x51, 0x64, 0xcd, 0x46, 0x03, 0xf8, 0xd9, 0x4e, 0xbf, 0x3c, 0xeb, 0x6c, 0xc4, 0xf1, 0xb5, 0x2c, 0x4b, 0x38, 0x19, 0xc9, 0x30, 0x00, 0xce, 0x71, 0x38, 0xfe, 0x64, 0x06, 0x7b, 0x5b, 0x1f, 0xeb, 0x87, 0xc5, 0xf3, 0xb7, 0x90, 0xf7, 0x05, 0xdb, 0x10, 0xeb, 0xc4, 0x50, 0xb3, 0x62, 0x0c, 0x2f, 0xdf, 0x6e, },
  {0x72, 0xa3, 0x36, 0xd5, 0x8a, 0x5f, 0xd1, 0x79, 0xba, 0x14, 0x47, 0xde, 0xd1, 0x7a, 0xec, 0xae, 0x2d, 0xe7, 0x79, 0x5c, 0x13, 0x7f, 0x68, 0xdf, 0x24, 0xa5, 0x32, 0x82, 0x65, 0xdd, 0x74, 0xf6, 0x60, 0x84, 0xe8, 0x50, 0xa2, 0xe3, 0x2a, 0x97, 0x4a, 0xbb, 0xa9, 0x2b, 0x45, 0xd5, 0x64, 0x0e, 0xaa, 0x25, 0x1b, 0x70, 0x42, 0x87, 0x63, 0x3c, 0x93, 0xe4, 0x25, 0x72, 0x99, 0xbd, 0x7e, 0x9d, },
  {0x5a, 0xb2, 0xfc, 0x28, 0x9b, 0xf3, 0x30, 0x4e, 0x8d, 0x26, 0x63, 0xac, 0x1c, 0x3f, 0xbf, 0x0c, 0x9d, 0x6b, 0x37, 0xc6, 0xa2, 0x2c, 0xb2, 0x05, 0x59, 0x96, 0xd7, 0x15, 0x02, 0xc7, 0x98, 0xa6, 0x0e, 0xb8, 0x76, 0x40, 0x17, 0x89, 0xb3, 0x0b, 0xde, 0x15, 0x85, 0xf9, 0x72, 0xb8, 0x52, 0x79, 0x3e, 0xe5, 0x5c, 0xa4, 0xc8, 0x2a, 0xff, 0xa8, 0x58, 0x03, 0x85, 0xd6, 0x42, 0xed, 0x21, 0x52, },
  {0x3e, 0x82, 0xbc, 0x4a, 0x0a, 0x6e, 0x1b, 0xcb, 0x9f, 0xe4, 0x7f, 0xf2, 0x2e, 0x71, 0x5b, 0x17, 0x8d, 0xd3, 0xb5, 0xed, 0x92, 0x45, 0xff, 0x8b, 0xcd, 0x4a, 0xf4, 0x3e, 0xad, 0x56, 0x20, 0x44, 0xd4, 0x28, 0x93, 0xf7, 0xc5, 0x57, 0x6a, 0xed, 0x3c, 0x55, 0xc6, 0xda, 0x37, 0x92, 0x17, 0xde, 0x9b, 0x81, 0xd3, 0xba, 0x50, 0x97, 0x13, 0xd1, 0x77, 0xbb, 0x34, 0xfb, 0x11, 0x8e, 0xb0, 0xe4, },
  {0xd0, 0x00, 0x62, 0xde, 0xac, 0xc2, 0xe8, 0x5a, 0x04, 0x39, 0xbd, 0x4c, 0x98, 0xc7, 0xf6, 0xdb, 0x49, 0x25, 0x53, 0x07, 0x1f, 0xdc, 0x70, 0x37, 0x11, 0xb6, 0x5f, 0x78, 0x90, 0xfc, 0x86, 0xe5, 0x6c, 0x53, 0xab, 0x0a, 0xd9, 0x23, 0xbc, 0x79, 0xa5, 0x90, 0x68, 0x1b, 0x9f, 0x05, 0xc9, 0xfd, 0x31, 0x49, 0x19, 0xed, 0x35, 0x6a, 0xe2, 0x1f, 0x47, 0x9d, 0x67, 0xc7, 0x4d, 0x5e, 0xce, 0x0b, },
  {0xc3, 0xf0, 0x1f, 0x93, 0x7a, 0x3d, 0x86, 0xb3, 0xfd, 0x6f, 0xd2, 0x11, 0x89, 0x06, 0xb0, 0x7d, 0xa5, 0xfb, 0x75, 0x85, 0xbe, 0x61, 0xc9, 0xa8, 0x81, 0xe4, 0x1b, 0xc0, 0x2a, 0xd0, 0x35, 0x07, 0xbe, 0xed, 0x38, 0x64, 0x7f, 0x9c, 0x33, 0x1a, 0xd1, 0xf4, 0x28, 0x4d, 0xe9, 0xad, 0x5a, 0x6c, 0xbd, 0x0a, 0x8d, 0x76, 0x01, 0xb3, 0x80, 0xc2, 0x2d, 0xf0, 0xad, 0x1a, 0x7b, 0xa4, 0x2b, 0x73, },
  {0xa1, 0x75, 0x34, 0x52, 0xf8, 0x0d, 0x2a, 0x46, 0x94, 0x21, 0xa7, 0x56, 0xe8, 0x67, 0x42, 0x33, 0x1a, 0x63, 0xe1, 0x3d, 0x9f, 0x4f, 0x0a, 0xf6, 0x29, 0x6a, 0x9c, 0xec, 0x4d, 0x66, 0xb4, 0x7e, 0x9b, 0x1a, 0xcc, 0x8c, 0x4b, 0xe5, 0xf9, 0x46, 0x5f, 0x0c, 0x7f, 0xb6, 0x74, 0x40, 0x87, 0x29, 0xa8, 0xf3, 0x62, 0xd8, 0xa0, 0xf6, 0x5b, 0x90, 0xda, 0x08, 0x8a, 0xe9, 0x3a, 0xdc, 0xf7, 0x41, },
  {0x89, 0x45, 0xd3, 0xa9, 0xc6, 0x69, 0xa3, 0xd8, 0x7b, 0x61, 0x34, 0xdd, 0xb6, 0x27, 0xef, 0xd1, 0x97, 0xc4, 0xad, 0x0f, 0xef, 0x31, 0x7a, 0x95, 0x47, 0xda, 0x3b, 0x05, 0xa9, 0x13, 0xe1, 0x5a, 0x47, 0x73, 0xff, 0x2b, 0xb6, 0x03, 0x6d, 0xc7, 0xb0, 0x97, 0xde, 0x31, 0xf2, 0xcf, 0x1f, 0xd9, 0x51, 0x96, 0xc7, 0x40, 0x26, 0x4b, 0x0f, 0x38, 0x72, 0x4f, 0x5f, 0x27, 0x9a, 0x04, 0xba, 0x92, },
  {0xdd, 0xb8, 0x0f, 0xed, 0x1b, 0x59, 0xe4, 0xba, 0x07, 0xf5, 0xc9, 0x1a, 0x74, 0xa0, 0x50, 0x86, 0x03, 0x58, 0x2a, 0x8c, 0xce, 0xb5, 0xdf, 0x20, 0xad, 0x5a, 0xcc, 0x83, 0x73, 0x94, 0xf3, 0x20, 0xd9, 0xa3, 0x0f, 0x5e, 0xd6, 0xa8, 0x15, 0x88, 0x3a, 0x54, 0xc2, 0x01, 0x8e, 0x60, 0x0f, 0xe8, 0x6f, 0x39, 0x1d, 0xb1, 0x86, 0xe7, 0xce, 0xa7, 0xfb, 0xc0, 0xb1, 0xd3, 0x6e, 0x53, 0x83, 0x63, },
  {0x23, 0x61, 0x80, 0x30, 0x9c, 0x8b, 0x38, 0x16, 0x50, 0x9a, 0x81, 0x3e, 0x8f, 0x10, 0xbc, 0x6e, 0xe3, 0xf3, 0x47, 0x70, 0x16, 0x65, 0x54, 0xc3, 0x8b, 0x12, 0xb8, 0xf9, 0x26, 0xc3, 0x41, 0x32, 0xb0, 0x81, 0xc4, 0x3b, 0x92, 0x52, 0x7b, 0xe1, 0xf1, 0x24, 0x67, 0xa4, 0x48, 0xbe, 0x9c, 0xb3, 0x82, 0x0c, 0xe1, 0x74, 0x58, 0xba, 0x69, 0x96, 0x23, 0x12, 0x82, 0x40, 0xc3, 0xe5, 0x16, 0x25, },
  {0x39, 0x94, 0xe5, 0x70, 0x49, 0xcf, 0xf1, 0x73, 0xc3, 0x29, 0xb2, 0xe9, 0x5d, 0xff, 0xcb, 0x1f, 0x39, 0xb3, 0x7e, 0xd7, 0x9c, 0xfd, 0x3d, 0x00, 0xf1, 0x6d, 0x33, 0x51, 0xa2, 0x5e, 0xd1, 0x8e, 0x07, 0x68, 0xf2, 0x21, 0xeb, 0xbb, 0x30, 0xa0, 0x1a, 0x73, 0xd2, 0xfe, 0x19, 0x7a, 0x3b, 0xf6, 0x2d, 0xcd, 0xa3, 0xfd, 0x07, 0x32, 0x16, 0x7d, 0x46, 0xe9, 0xa1, 0x0d, 0xf8, 0x34, 0xa9, 0xcf, },
  {0xd0, 0x51, 0xc0, 0x06, 0xb4, 0x24, 0x7f, 0xa8, 0x65, 0xde, 0x4b, 0x00, 0xd4, 0x2f, 0x46, 0xa5, 0x62, 0x92, 0x12, 0x33, 0xab, 0x23, 0x86, 0x78, 0xe4, 0x9a, 0xd4, 0x1c, 0xe7, 0x11, 0x6e, 0xba, 0xde, 0x53, 0x99, 0x45, 0x72, 0x11, 0x63, 0xca, 0x44, 0xaf, 0x8a, 0x34, 0xe3, 0x57, 0xc8, 0x68, 0x4e, 0x91, 0x5e, 0x43, 0x8b, 0xd7, 0xf2, 0xc7, 0x60, 0xdb, 0x2c, 0x58, 0x77, 0x90, 0x68, 0x50, },
  {0xef, 0x18, 0xa6, 0xfb, 0x5f, 0xdb, 0x0b, 0x40, 0xf9, 0x14, 0x8c, 0x6b, 0xac, 0x99, 0x80, 0x09, 0xdc, 0xf8, 0xc1, 0x5c, 0xe9, 0xc8, 0x4a, 0xa7, 0x2b, 0x5f, 0x44, 0xb1, 0x7b, 0x89, 0x4b, 0xf7, 0x2b, 0x19, 0xad, 0xcf, 0x8a, 0xdb, 0xfa, 0x08, 0x98, 0xe7, 0x50, 0x0a, 0x83, 0xaa, 0x23, 0x04, 0xec, 0x17, 0xaf, 0xc3, 0x21, 0x9d, 0x53, 0x3b, 0xb3, 0x6d, 0x8b, 0xbc, 0xd6, 0x06, 0xb6, 0xf0, },
  {0x86, 0x45, 0x29, 0x8e, 0x35, 0x9f, 0x53, 0xcc, 0x94, 0x32, 0xbf, 0x79, 0x23, 0xf2, 0x55, 0xba, 0x71, 0x27, 0x4f, 0x07, 0x8e, 0x6b, 0x18, 0xdb, 0xbc, 0x09, 0x91, 0xfd, 0xc5, 0x02, 0x38, 0xa5, 0x79, 0x5f, 0xe5, 0x04, 0x35, 0xa8, 0x4d, 0x7f, 0x5f, 0x29, 0xbb, 0xce, 0x6d, 0xda, 0x97, 0xba, 0x77, 0xd3, 0x37, 0x6b, 0x7f, 0xe5, 0xab, 0x0b, 0x94, 0x18, 0xed, 0x4a, 0x20, 0x9e, 0x41, 0x13, },
  {0xb8, 0xd8, 0x78, 0xc7, 0x6a, 0xe9, 0x85, 0x1f, 0xb1, 0x59, 0xee, 0x3d, 0xc5, 0x0e, 0xe3, 0x8a, 0x3d, 0x9d, 0xd3, 0x7b, 0xb7, 0x39, 0xf5, 0x57, 0xcd, 0x75, 0x3b, 0x67, 0x29, 0xd8, 0x98, 0xec, 0xca, 0x3e, 0xbd, 0x81, 0x6a, 0x24, 0xc5, 0xb5, 0x38, 0xf5, 0x15, 0x93, 0x41, 0x2e, 0xf9, 0x46, 0x87, 0xe1, 0x28, 0xf8, 0x00, 0x48, 0x75, 0x29, 0xff, 0xcf, 0x38, 0xac, 0x64, 0xfb, 0xda, 0x7e, },
  {0x20, 0x57, 0xec, 0x02, 0x42, 0x16, 0xbc, 0x70, 0xe2, 0x05, 0xa0, 0xd5, 0x50, 0x68, 0x33, 0xcd, 0x1a, 0xae, 0xee, 0x44, 0xe0, 0x98, 0x0d, 0x83, 0xa1, 0x21, 0xdf, 0xaa, 0x4f, 0xb6, 0x59, 0x22, 0x0a, 0x91, 0xfd, 0x51, 0xa0, 0xee, 0x17, 0x8e, 0xda, 0x77, 0xa6, 0x64, 0xeb, 0x10, 0x5b, 0xa1, 0x0b, 0x53, 0xa6, 0x95, 0xb6, 0xd0, 0x64, 0xbd, 0x85, 0x56, 0x08, 0x80, 0xc8, 0x2d, 0x52, 0x71, },
  {0xfa, 0x38, 0xb0, 0x96, 0xd3, 0xa5, 0xfc, 0x28, 0x48, 0x63, 0x80, 0x17, 0x97, 0xb4, 0x7a, 0xfb, 0x5d, 0x02, 0x6a, 0x2d, 0x1b, 0x60, 0xb2, 0x31, 0x4c, 0xf1, 0x12, 0x7f, 0xe8, 0x18, 0x72, 0x87, 0x66, 0xb0, 0x2a, 0x14, 0xce, 0x5b, 0x40, 0x6d, 0x00, 0xcb, 0x54, 0x1f, 0xc1, 0xb0, 0x74, 0xcf, 0x1e, 0x67, 0xc7, 0x3b, 0x5a, 0x16, 0xe9, 0x34, 0xa4, 0xdf, 0x72, 0x9b, 0xe9, 0x8e, 0x01, 0xc0, },
  {0xa4, 0x14, 0x82, 0x5e, 0x2e, 0x50, 0x7b, 0x90, 0xd9, 0xaa, 0xf5, 0x2d, 0xe8, 0x1f, 0xa7, 0x49, 0x93, 0xbe, 0x80, 0xa2, 0xc4, 0xfe, 0x70, 0xd3, 0x92, 0xc2, 0x5c, 0x8c, 0xcd, 0x43, 0xf7, 0xc2, 0xe1, 0x48, 0xd9, 0x76, 0x95, 0xe0, 0xac, 0xf9, 0x27, 0x9b, 0x45, 0xdc, 0x7f, 0x8e, 0x39, 0xe6, 0xb8, 0xf5, 0x82, 0x10, 0xd8, 0x8a, 0x9a, 0x1d, 0x4c, 0xc2, 0x25, 0x3e, 0x15, 0x5f, 0xad, 0xf2, },
  {0x09, 0xe6, 0x70, 0xb9, 0xf3, 0x0b, 0xc6, 0x37, 0x13, 0xcd, 0x40, 0x8d, 0x5a, 0xc9, 0x0c, 0xde, 0x27, 0xf1, 0x52, 0xda, 0x89, 0x47, 0x24, 0xea, 0x02, 0x3e, 0xa7, 0x2d, 0x06, 0x9a, 0x34, 0xa3, 0x0e, 0x7f, 0x38, 0xba, 0x09, 0x31, 0x7f, 0x4e, 0xbd, 0x87, 0xf1, 0x30, 0x05, 0xff, 0x50, 0x29, 0x93, 0x44, 0x71, 0x2d, 0xee, 0x42, 0x78, 0xf8, 0x0e, 0x68, 0xf1, 0xb6, 0xd0, 0x48, 0xe2, 0x84, },
  {0xbd, 0xd0, 0x48, 0x1c, 0xdd, 0x69, 0x9b, 0x58, 0xb5, 0x6f, 0x09, 0xbd, 0x6a, 0x38, 0x84, 0x70, 0x3f, 0xd0, 0x11, 0x37, 0x08, 0xac, 0x59, 0x7d, 0xb6, 0x69, 0xfb, 0x76, 0xbb, 0x61, 0xd3, 0x25, 0x56, 0xf2, 0xa8, 0x5e, 0xec, 0x1f, 0xc9, 0x61, 0xe5, 0x0c, 0x72, 0xa8, 0x67, 0xc9, 0x13, 0x60, 0xa9, 0x03, 0xe4, 0xbf, 0xae, 0x61, 0xca, 0xa8, 0xdb, 0x92, 0x5a, 0xa3, 0x7b, 0x1f, 0x6a, 0x37, },
  {0x3b, 0x9a, 0x28, 0x8d, 0xab, 0x3e, 0xe8, 0x23, 0xf0, 0x7d, 0x4d, 0xfe, 0xa4, 0xd7, 0xea, 0xb9, 0x9e, 0x62, 0xb1, 0x76, 0xe8, 0xcc, 0x9c, 0x16, 0xe0, 0x4f, 0x1f, 0xd7, 0xeb, 0x4a, 0x6d, 0xb3, 0x91, 0x1c, 0xc4, 0x70, 0x4a, 0x8d, 0x9f, 0x13, 0x39, 0xb5, 0x59, 0xd5, 0x3d, 0xba, 0x9e, 0xdf, 0x77, 0xd3, 0x4d, 0x9c, 0x21, 0x06, 0x54, 0x28, 0x39, 0x83, 0x03, 0x31, 0xfd, 0xc5, 0xd8, 0x09, },
  {0xdf, 0x74, 0xfe, 0x55, 0xcc, 0x84, 0x01, 0xa8, 0x8a, 0xe0, 0x1d, 0x93, 0x29, 0x03, 0x54, 0x15, 0x8b, 0x21, 0xfa, 0x91, 0x67, 0x2b, 0x3d, 0x8a, 0xc6, 0x34, 0xa1, 0x8f, 0x14, 0x85, 0x09, 0xff, 0xe4, 0x3f, 0x88, 0x02, 0xd6, 0xfc, 0xb1, 0x76, 0xd0, 0x8c, 0x1c, 0xea, 0x92, 0x25, 0x82, 0xf6, 0x1c, 0x35, 0x86, 0x6a, 0xfd, 0x90, 0xbc, 0x6f, 0xd3, 0xb2, 0xec, 0x4f, 0x12, 0x8a, 0xaa, 0x54, },
  {0x5b, 0x18, 0xb6, 0x0e, 0x31, 0x76, 0xbe, 0x60, 0x44, 0x32, 0xc5, 0x62, 0xb2, 0x46, 0x7e, 0xf6, 0x32, 0xc6, 0x49, 0x17, 0xbc, 0x53, 0xd6, 0xf9, 0x71, 0x0b, 0xb3, 0x58, 0x40, 0xca, 0x9e, 0x77, 0x2c, 0x65, 0xcc, 0x9b, 0x35, 0x26, 0x68, 0x44, 0xf3, 0x2d, 0xa1, 0x4b, 0x10, 0x6f, 0x54, 0x41, 0xc1, 0xb1, 0x59, 0x11, 0xcf, 0x40, 0x80, 0xf5, 0x1b, 0x44, 0xc3, 0x73, 0x99, 0x5e, 0x3d, 0x23, },
  {0x33, 0x92, 0xd9, 0x67, 0xed, 0x4a, 0xd8, 0xfa, 0x13, 0xa0, 0xd5, 0x76, 0xee, 0x9a, 0xcf, 0x68, 0xab, 0x5b, 0xdc, 0xa2, 0xed, 0x81, 0x04, 0xaa, 0x5f, 0xe5, 0x7c, 0xf2, 0x24, 0xdc, 0x37, 0xbe, 0x51, 0xda, 0x12, 0xaf, 0x5a, 0xe4, 0xc1, 0x0e, 0x55, 0xdb, 0x79, 0xc3, 0xfa, 0xae, 0xcf, 0x0c, 0x95, 0xdc, 0x29, 0xeb, 0xa4, 0x30, 0xe3, 0x10, 0x62, 0x8c, 0xa1, 0x2a, 0xe4, 0xba, 0xf2, 0xdc, },
  {0xa6, 0x46, 0x85, 0xc2, 0xa1, 0x17, 0x28, 0x95, 0x6e, 0xb7, 0x09, 0x57, 0x19, 0x3c, 0xbc, 0x0f, 0xe4, 0x78, 0x06, 0x3b, 0x27, 0x6d, 0x9a, 0x1e, 0x45, 0x2d, 0xbc, 0x95, 0x6c, 0xad, 0x5e, 0x1a, 0xa7, 0x80, 0xf8, 0x4c, 0x79, 0x19, 0x84, 0x95, 0xaa, 0x03, 0x64, 0x3a, 0x87, 0xe1, 0x31, 0x5f, 0xf0, 0x74, 0x8a, 0xba, 0x4b, 0x77, 0x9b, 0xaf, 0x53, 0xe9, 0xcb, 0x06, 0x6a, 0x19, 0x82, 0x32, },
  {0x63, 0xf9, 0x05, 0x3c, 0x7b, 0x5c, 0xae, 0xce, 0x53, 0x39, 0xf7, 0x85, 0xdf, 0x2d, 0x8d, 0x4e, 0x24, 0x98, 0x85, 0xb6, 0xcc, 0x4d, 0xf3, 0xc3, 0x8d, 0xd1, 0x19, 0x4d, 0x00, 0xf9, 0x8b, 0xec, 0x06, 0x95, 0x27, 0xbc, 0xdd, 0xa1, 0xf6, 0x3c, 0xca, 0xe7, 0xbb, 0x27, 0x9b, 0x08, 0x6b, 0xa3, 0x19, 0x44, 0x01, 0x65, 0x1f, 0xc7, 0x09, 0xd7, 0x36, 0x1e, 0x7e, 0x40, 0xd3, 0x4c, 0xb2, 0x11, },
  {0x53, 0xb2, 0xd1, 0x22, 0xdf, 0xf3, 0x83, 0x0e, 0xe5, 0x8f, 0x25, 0xab, 0xc8, 0x6f, 0xa3, 0xf4, 0xd3, 0x43, 0xff, 0x63, 0xd9, 0x0f, 0xaf, 0x36, 0xea, 0x68, 0xa3, 0xe1, 0xc4, 0x2f, 0x49, 0x73, 0xce, 0x43, 0x6a, 0x38, 0x0c, 0x5f, 0x2b, 0x6e, 0x4b, 0x7f, 0x15, 0x5a, 0xed, 0x49, 0xb9, 0x80, 0xd8, 0xca, 0xaa, 0xf5, 0xde, 0x57, 0x93, 0x6b, 0xba, 0xf1, 0xaa, 0x5b, 0xfc, 0x8b, 0x9f, 0x73, },
  {0x8a, 0x2d, 0x6e, 0x9b, 0x50, 0xba, 0x32, 0x43, 0x76, 0xc2, 0x66, 0x49, 0x03, 0xeb, 0x5a, 0x0c, 0x6c, 0xae, 0x18, 0x2f, 0x91, 0x75, 0x5c, 0x83, 0x08, 0x54, 0x77, 0x3a, 0x82, 0xd4, 0x9f, 0x1f, 0xe3, 0xac, 0xf2, 0xca, 0x91, 0xb3, 0xd4, 0xeb, 0x1e, 0x8e, 0xb2, 0xd5, 0x74, 0xc8, 0x1e, 0xfc, 0x39, 0x53, 0x99, 0x31, 0x82, 0x3d, 0xfe, 0x29, 0x49, 0x74, 0x96, 0x30, 0xbd, 0x24, 0xe3, 0x3a},
};


void fillDitheredTriangle(JaDraw<WIDTH, HEIGHT>& canvas, unsigned long millis,
     const Vec2i* v1, const Vec2i* v2, const Vec2i* v3, float brightness)
{
    // --- Initial Setup ---

    // Sort vertices by Y coordinate (p0.y <= p1.y <= p2.y) using pointers to avoid copies.
    const Vec2i* p[3] = {v1, v2, v3};
    if (p[0]->y > p[1]->y) std::swap(p[0], p[1]);
    if (p[1]->y > p[2]->y) std::swap(p[1], p[2]);
    if (p[0]->y > p[1]->y) std::swap(p[0], p[1]);

    const Vec2i& p0 = *p[0];
    const Vec2i& p1 = *p[1];
    const Vec2i& p2 = *p[2];

    // Early exit if the triangle is completely outside the screen
    if (p2.y < 0 || p0.y >= canvas.height) return;
    if (std::max({p0.x, p1.x, p2.x}) < 0 || std::min({p0.x, p1.x, p2.x}) >= canvas.width) return;

    // --- Fixed-Point Setup ---

    // This is the ONLY floating-point operation, performed once per triangle.
    // It converts the 0.0-1.0 brightness into a 0-255 integer threshold.
    int32_t brightness_level = static_cast<int32_t>(brightness * 255.0f);

    // Get animated offset for "sizzling" noise. Your original values were very fast,
    // so I have kept them.
    uint8_t offsetX = (millis / 3) & 63;
    uint8_t offsetY = (millis / 11) & 63;

    // We'll use 16.16 fixed-point precision. (16 bits for integer, 16 for fraction)
    const int FIXED_POINT_SHIFT = 16;

    // --- Rasterize Top Half of Triangle ---
    int32_t height01 = p1.y - p0.y;
    if (height01 > 0) {
        int32_t height02 = p2.y - p0.y;
        // Calculate slopes (dx/dy) using fixed-point math
        int32_t slope1 = ((p1.x - p0.x) << FIXED_POINT_SHIFT) / height01;
        int32_t slope2 = ((p2.x - p0.x) << FIXED_POINT_SHIFT) / height02;

        int32_t x1 = p0.x << FIXED_POINT_SHIFT;
        int32_t x2 = p0.x << FIXED_POINT_SHIFT;

        for (int y = p0.y; y < p1.y; ++y) {
            // Only draw scanlines that are on-screen
            if (y >= 0 && y < canvas.height) {
                int startX = x1 >> FIXED_POINT_SHIFT;
                int endX   = x2 >> FIXED_POINT_SHIFT;
                if (startX > endX) std::swap(startX, endX);
                
                // Clip and draw the horizontal line
                for (int x = std::max(0, startX); x < std::min(canvas.width, endX); ++x) {
                    uint8_t threshold = BLUE_NOISE_64x64[(y + offsetY) & 63][(x + offsetX) & 63];
                    if (brightness_level > threshold) {
                        canvas.drawPixel(x, y, Colors::White);
                    }
                }
            }
            // Increment x positions by their slopes for the next line
            x1 += slope1;
            x2 += slope2;
        }
    }

    // --- Rasterize Bottom Half of Triangle ---
    int32_t height12 = p2.y - p1.y;
    if (height12 > 0) {
        int32_t height02 = p2.y - p0.y;
        // Calculate slopes. The long edge's slope (p0-p2) is the same.
        int32_t slope1 = ((p2.x - p1.x) << FIXED_POINT_SHIFT) / height12;
        int32_t slope2 = ((p2.x - p0.x) << FIXED_POINT_SHIFT) / height02;

        // Start x positions at the middle vertex and the corresponding point on the long edge
        int32_t x1 = p1.x << FIXED_POINT_SHIFT;
        int32_t x2 = (p0.x << FIXED_POINT_SHIFT) + slope2 * height01;

        for (int y = p1.y; y <= p2.y; ++y) {
            if (y >= 0 && y < canvas.height) {
                int startX = x1 >> FIXED_POINT_SHIFT;
                int endX   = x2 >> FIXED_POINT_SHIFT;
                if (startX > endX) std::swap(startX, endX);

                for (int x = std::max(0, startX); x < std::min(canvas.width, endX); ++x) {
                    uint8_t threshold = BLUE_NOISE_64x64[(y + offsetY) & 63][(x + offsetX) & 63];
                    if (brightness_level > threshold) {
                        canvas.drawPixel(x, y, Colors::White);
                    }
                }
            }
            x1 += slope1;
            x2 += slope2;
        }
    }
}
static void draw_3d_model(JaDraw<WIDTH, HEIGHT>& canvas, unsigned long millis, const Mat4f* vp_matrix,
                          const Vec3f* vertices, const int* indices, int num_indices,
                          Vec3f position, float rotation_x_rad, float rotation_y_rad, float rotation_z_rad, float scale,
                          const Vec3f* world_light_dir)
{
    // 1. Create Model and MVP Matrices (same as before)
    Mat4f scale_mat = matrix_scale((Vec3f){scale, scale, scale});
    Mat4f rot_mat = matrix_multiply(
        matrix_multiply( // order matters
            matrix_rotate_y(rotation_y_rad),
            matrix_rotate_x(rotation_x_rad)),
        matrix_rotate_z(rotation_z_rad)
    );
    Mat4f trans_mat = matrix_translate(position);
    Mat4f model_matrix = matrix_multiply(trans_mat, matrix_multiply(rot_mat, scale_mat));
    Mat4f mvp_matrix = matrix_multiply(*vp_matrix, model_matrix);

    const float AMBIENT_LIGHT = 0.0f;
    const float DIFFUSE_STRENGTH = 1.5f;

    // 2. Process and draw each triangle
    for (int i = 0; i < num_indices; i += 3) {
        const Vec3f* v_model[3];
        v_model[0] = &vertices[indices[i]];
        v_model[1] = &vertices[indices[i+1]];
        v_model[2] = &vertices[indices[i+2]];

        // --- Projection ---
        // Project all three vertices first.
        Vec2i v_screen[3];
        bool p1_visible = project_vertex(v_model[0], &mvp_matrix, &v_screen[0], WIDTH, HEIGHT);
        bool p2_visible = project_vertex(v_model[1], &mvp_matrix, &v_screen[1], WIDTH, HEIGHT);
        bool p3_visible = project_vertex(v_model[2], &mvp_matrix, &v_screen[2], WIDTH, HEIGHT);

        // If all three vertices are behind the camera, skip the whole triangle.
        // This is a simple but effective form of clipping.
        if (!p1_visible && !p2_visible && !p3_visible) {
            continue;
        }
        // A more robust check would be if ANY vertex is valid, but this is often good enough.
        // if (!p1_visible && !p2_visible && !p3_visible) continue;
        // Or even better, if all are invalid
        // if (!(p1_visible || p2_visible || p3_visible)) continue;


        // --- Back-face Culling ---
        // Use screen-space winding order. This is fast and effective.
        int cross_product_z = (v_screen[1].x - v_screen[0].x) * (v_screen[2].y - v_screen[0].y) -
                              (v_screen[1].y - v_screen[0].y) * (v_screen[2].x - v_screen[0].x);

        if (cross_product_z < 0) { // If triangle is facing the camera
            // --- Lighting Calculation (in World Space) ---
            // We do this *after* culling, because it's wasted computation on a triangle we won't draw.
            Vec3f v_world[3];
            v_world[0] = transform_vertex(v_model[0], &model_matrix);
            v_world[1] = transform_vertex(v_model[1], &model_matrix);
            v_world[2] = transform_vertex(v_model[2], &model_matrix);

            Vec3f edge1 = vec3_subtract(v_world[1], v_world[0]);
            Vec3f edge2 = vec3_subtract(v_world[2], v_world[0]);
            Vec3f face_normal = vec3_normalize(vec3_cross(edge1, edge2));

            float diffuse_intensity = vec3_dot(face_normal, *world_light_dir);

            // Final brightness calculation
            float brightness = AMBIENT_LIGHT;
            if (diffuse_intensity > 0) {
                brightness += diffuse_intensity * DIFFUSE_STRENGTH;
            }
            if (brightness > 1.0f) brightness = 1.0f;

            // --- Drawing ---
            // The rasterizer will handle clipping the triangle to the screen bounds.
            fillDitheredTriangle(canvas, millis, &v_screen[0], &v_screen[1], &v_screen[2], brightness);
        }
    }
}
/**
 * @brief Draws a point in 3D space with a specified size that respects perspective.
 *
 * @param canvas The canvas to draw on.
 * @param vp_matrix The combined View-Projection matrix.
 * @param world_position The position of the point in world space.
 * @param size The desired radius of the point in world space units.
 */
static void draw_3d_point(JaDraw<WIDTH, HEIGHT>& canvas, const Mat4f* vp_matrix,
                          Vec3f world_position, float size)
{
    // A point needs a center and an edge to define its size in the world.
    // We create a second point offset by `size` along the Y-axis.
    Vec3f center_world = world_position;
    Vec3f edge_world   = {world_position.x, world_position.y + size, world_position.z};

    // 1. Project the center of the point to find its screen position.
    Vec2i screen_pos;
    if (!project_vertex(&center_world, vp_matrix, &screen_pos, WIDTH, HEIGHT)) {
        // If the center isn't on screen (or is behind the camera), we can't draw it.
        return;
    }

    // 2. Project the "edge" point to determine the size in pixels.
    Vec2i screen_edge;
    if (!project_vertex(&edge_world, vp_matrix, &screen_edge, WIDTH, HEIGHT)) {
        // If the edge point is not projectable (e.g. behind camera), we can't
        // reliably calculate a size, so we can either draw a minimal 1x1 point
        // or just skip it. Skipping is safer to avoid visual artifacts.
        // For a small point, it's often fine to just draw a single pixel.
        //canvas.setPixel(screen_pos.x, screen_pos.y);
        return;
    }

    // 3. Calculate the radius in pixels using the distance between the projected points.
    // We use the distance formula, but since our offset was only on one axis (Y),
    // we can simplify it. Using the full distance formula would also work and be
    // more robust if the offset was in a more complex direction.
    float dx = screen_pos.x - screen_edge.x;
    float dy = screen_pos.y - screen_edge.y;
    float screen_radius = sqrtf(dx * dx + dy * dy);

    // 4. Calculate the final width/height of the rectangle (diameter).
    // We ensure it's at least 1 pixel wide so it doesn't disappear when very far away.
    int w = (int)(screen_radius * 2.0f);
    if (w < 1) {
        w = 1;
    }

    // 5. Draw the filled rectangle centered on the projected point's position.
    // The `true` likely corresponds to the color/fill state.
    draw_filled_rect(canvas, screen_pos.x - (w / 2), screen_pos.y - (w / 2), w, w, true);
}

// Helper to convert world coordinates [-1, 1] to screen pixels [0, Res-1]
static void world_to_screen(float wx, float wy, uint8_t* sx, uint8_t* sy) {
    *sx = (uint8_t)((wx + 1.0f) * 0.5f * WIDTH);
    // Y is inverted: world +1 is top, screen 0 is top
    *sy = (uint8_t)((-wy + 1.0f) * 0.5f * HEIGHT);
}

// Helper to draw a simple filled rectangle
static void draw_filled_rect(JaDraw<WIDTH, HEIGHT>& canvas, uint8_t x, uint8_t y, uint8_t w, uint8_t h, bool white) {
    // Clamp width and height to avoid overflow and infinite loops
    if (x >= WIDTH || y >= HEIGHT) return;
    uint8_t max_w = (x + w > WIDTH) ? (WIDTH - x) : w;
    uint8_t max_h = (y + h > HEIGHT) ? (HEIGHT - y) : h;
    for (uint8_t i = x; i < (uint8_t)(x + max_w); ++i) {
        for (uint8_t j = y; j < (uint8_t)(y + max_h); ++j) {
            drawPixel(canvas, i, j, white);
        }
    }
}

// Draws the GAME OVER message using rectangles
void draw_game_over(JaDraw<WIDTH, HEIGHT>& canvas) {
    // Simple "GAME OVER" text using rectangles
    // G
    draw_filled_rect(canvas, 20, 20, 15, 3, true); draw_filled_rect(canvas, 20, 20, 3, 15, true); draw_filled_rect(canvas, 20, 32, 15, 3, true); draw_filled_rect(canvas, 32, 26, 3, 9, true); draw_filled_rect(canvas, 28, 26, 5, 3, true);
    // O
    draw_filled_rect(canvas, 40, 20, 15, 3, true); draw_filled_rect(canvas, 40, 20, 3, 15, true); draw_filled_rect(canvas, 52, 20, 3, 15, true); draw_filled_rect(canvas, 40, 32, 15, 3, true);
    // ... and so on for the rest of the text. This is tedious but works without fonts.
    // For brevity, we'll just show one letter.
}


/**
 * @brief Renders the 2D game state in a 3D world using the "On-the-Fly Interpretation" strategy.
 *
 * This function reads a pure 2D GameState and generates 3D visual data (like Y-coordinates
 * and rotations) temporarily for rendering purposes only. The core GameState is not modified
 * and contains no 3D data.
 *
 * @param state   A pointer to the const 2D game state.
 * @param canvas  Pointer to the canvas to draw on.
 * @param millis  Current timestamp in milliseconds for procedural effects like rotation.
 */
static void draw_game_3d(const GameState* state, JaDraw<WIDTH, HEIGHT>& canvas, unsigned long millis) {
    clear_canvas(canvas);

    if (state->gameOver) {
        draw_game_over(canvas);
        return;
    }

    // --- Setup Camera and Projection (once per frame) ---
    Vec3f camera_pos = {0.0f, -0.20f, -1.3f};
    Vec3f camera_target = {0.0f, 0.0f, 0.0f};
    Vec3f up_vector = {0.0f, -1.0f, 0.0f};
    Mat4f view_matrix = matrix_look_at(camera_pos, camera_target, up_vector);
    
    float fov_rad = 70.0f * (3.14159f / 180.0f);
    float aspect_ratio = (float)WIDTH / (float)HEIGHT;
    Mat4f proj_matrix = matrix_perspective(fov_rad, aspect_ratio, 0.1f, 100.0f);

    Mat4f vp_matrix = matrix_multiply(proj_matrix, view_matrix);
    //Vec3f sun_direction = vec3_normalize((Vec3f){0.5f, 0.8f, -0.3f});
    Vec3f sun_direction = vec3_normalize((Vec3f){0.7f, -0.7f, -0.2f});
    // --- Draw Player ---
    {
        // ADAPTATION: Convert 2D game position to a 3D world position on the XZ plane.
        Vec3f player_pos_3d = {state->player.pos.x, 0.0f, state->player.pos.y};
        
        // The player ship can remain unrotated for a clean look.
        float player_rotation_y = 3.1f; 
        float player_scale = 0.25f;
        float tilt = state->player.vel * -35.0f;
        draw_3d_model(canvas, millis, &vp_matrix, SHIP_VERTICES, SHIP_INDICES, SHIP_NUM_INDICES,
                      player_pos_3d, 0, player_rotation_y, tilt, player_scale, &sun_direction);
    }

    // --- Draw Bullets ---
    for (int i = 0; i < MAX_BULLETS; ++i) {
        if (state->bullets[i].active) {
            // ADAPTATION: Convert 2D bullet position to 3D world position.
            Vec3f bullet_pos_3d = {state->bullets[i].pos.x, 0.0f, state->bullets[i].pos.y};
            
            // Bullets are simple; no rotation needed.
            // draw_3d_model(canvas, millis, &vp_matrix, CUBE_VERTICES, CUBE_INDICES, CUBE_NUM_INDICES,
            //               bullet_pos_3d, 0, 0.0f, 0, 0.04f, &sun_direction);
            draw_3d_point(canvas, &vp_matrix, bullet_pos_3d, 0.03f);
        }
    }

    // --- Draw Asteroids ---
    for (int i = 0; i < MAX_ASTEROIDS; ++i) {
        if (state->asteroids[i].active) {
            // ADAPTATION: Convert 2D asteroid position to 3D world position.
            Vec3f asteroid_pos_3d = {state->asteroids[i].pos.x, 0.0f, state->asteroids[i].pos.y};
            
            // GENERATION: Create a procedural rotation that doesn't exist in the game state.
            // This makes them spin visually without affecting gameplay. The offset `i * 0.77f`
            // ensures they don't all spin in perfect sync.
            float time_sec = millis / 1000.0f;
            float rotation_y = (time_sec * 1.2f) + (i * 0.77f);
            
            // Use the asteroid's 2D size directly for 3D scaling.
            float scale = state->asteroids[i].size * 1.0f; // Adjust scale factor as needed

            draw_3d_model(canvas, millis, &vp_matrix, CUBE_VERTICES, CUBE_INDICES, CUBE_NUM_INDICES,
                          asteroid_pos_3d, rotation_y, rotation_y, 0, scale, &sun_direction);
        }
    }
    
    // --- Draw Laser ---
    if (state->laser.active) {
        // The laser is a special case: a tall, thin wall.
        // We build its model matrix manually for non-uniform scaling.
        Mat4f scale_mat = matrix_scale((Vec3f){0.02f, 2.0f, 2.0f}); // Thin in X, tall in Y/Z
        Mat4f trans_mat = matrix_translate((Vec3f){state->laser.x_pos, 0.0f, 0.0f});
        Mat4f model_matrix = matrix_multiply(trans_mat, scale_mat);

        // Create the final MVP matrix just for this object.
        Mat4f laser_mvp = matrix_multiply(vp_matrix, model_matrix);

        // This would require a modification to draw_3d_model or drawing it manually here.
        // For simplicity, we can reuse draw_3d_model by just passing in a pre-made MVP.
        // (This would be an extension to the helper, but the concept stands).
        // Let's just draw a standard cube there for now.
        Vec3f laser_pos_3d = { state->laser.x_pos, 0.0f, 0.0f };
        draw_3d_model(canvas, millis, &vp_matrix, CUBE_VERTICES, CUBE_INDICES, CUBE_NUM_INDICES,
                          laser_pos_3d, 0, 0.0f, 0, 0.5f, &sun_direction); // Simplified representation
    }
    
    // --- Draw UI (HP Bar) ---
    // The UI is pure 2D screen space and is unaffected by the 3D world.
    // We use the helper that draws a rect from two triangles.
    uint8_t hp_bar_width = (uint8_t)((state->player.hp / PLAYER_INITIAL_HP) * (WIDTH - 4));
    draw_filled_rect(canvas, 2, HEIGHT - 1, hp_bar_width, 1, true);
}
